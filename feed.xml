<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Kumar Ayush' Blog</title>
        <description>I am an everyday data scientist and developer who likes to turn dreams into reality. My magical staff is called an undergraduate degree in Physics mixed with experience in astronomy, web development, computer graphics and management.
</description>
        <link>http://cheekujodhpur.github.io</link>
        <atom:link href="http://cheekujodhpur.github.io/feed.xml" rel="self" type="application/rss+xml" />
        
        
        <item>
            <title>Hack InOut 6.0</title>
            <description>&lt;p&gt;Hello readers! Meet and I participated in the 6th edition of &lt;a href=&quot;https://hackinout.co&quot;&gt;Hack InOut&lt;/a&gt; this year.
It was very convenient as both of us are now employed in Bengaluru. 
We took a repeat shot at our augmented reality venture that was &lt;a href=&quot;/projects/bellatrix.html&quot; target=&quot;_blank&quot;&gt;Bellatrix&lt;/a&gt;.
I recommend reading that tiny post before you read this post, but it is not critical to understanding the following.
&lt;/p&gt;
&lt;h4&gt;The Challenge&lt;/h4&gt;
&lt;p&gt;Think of it like you’re making a gaming hardware. Your display is a screen that is being projected upon.
Your input is an object hitting the screen and a camera detecting the point hit. An alternative method of detecting the point hit is using a LIDAR as in &lt;a href=&quot;http://www.initi.org/workss/demonz-i-installation-for-kids-prague-handball-cup-2016&quot;&gt;INITI Playgroundz project&lt;/a&gt;.
We want(ed) to achieve the camera-based detection because it then opens the road to easy installation by anyone who has a projector and camera the quality of which comes in your phone. In theory, you could use your phone camera indeed.&lt;/p&gt;
&lt;p&gt;When we had attempted this problem in the name of Bellatrix, we had two significant problems:
&lt;ul&gt;
    &lt;li&gt;You think you can detect the ball via the difference of the frame that the camera detects and what we know is projected. However, the projector has an intense (in the literal meaning of high intensity) color emissivity. This means that the camera does not see the ball in its natural colour. It sees a ball colour graded by the projected frame. This makes it very difficult to discern the ball from the background.
        Sure, you could make arguments that the projection on the ball is &lt;i&gt;warped&lt;/i&gt; and so on but you have to keep in mind that we're working with a low-resolution RPi camera. Such effects are also harder to distinguish.
We were heavily relying on the ease of detecting a bright blob in heavily ambiguous video feeds. We put all our eggs in this one basket which had a big hole in it.&lt;/li&gt;
    &lt;li&gt;The key computation in the project is taking the difference of the frame the camera reads and the frame you project. The read operation requires several transformations which are heavy enough to drop your framerates to about 5 fps. That game is not likely to be a fun experience to play.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;
The way we tackled both of those issues in Bellatrix is by making our game a dartboard with a white background and the board was drawn with extra light font. This makes it easy to detect the ball &lt;b&gt;and&lt;/b&gt; you do not need a high frame rate for this game. The judges were impressed. It worked. &lt;br /&gt;
This time around, we wanted to improve on these areas. Spoiler here is that we made zero improvements on the ball detection and miserably failed after making a colourful game. Even the poor but working algorithm from Bellatrix failed. We ended up one step behind on this front. Anyway, this post is more about glorifying what we &lt;i&gt;did&lt;/i&gt; achieve rather than did not so here goes.
&lt;/p&gt;
&lt;p&gt;
We had an RPi 4 which turns out to hold 4 cores. The algorithm is simple. &lt;ol&gt;
    &lt;li&gt;Mark each frame with a unique binary code. We colored the four corners in a particular way, so you get 1 to 16.&lt;/li&gt;
    &lt;li&gt;The camera read and render are running on separate processes. The rendering process writes 16 frames in a looping fashion to a shared mem object. &lt;/li&gt;
    &lt;li&gt;Assuming your read is not lagging by more than 16 frames, you can pick the projected frame from the shared mem and do a diff (which is done via a third process)&lt;/li&gt;
    &lt;li&gt;The diff process will send the location of the hit point when it has it to the render process which can then include it in the game logic&lt;/li&gt;
&lt;/ol&gt;
This worked beautifully. We could churn out 30 fps and more throttled only by the occasional overheating of the RPi. However, the whole thing together was a disaster since we could not detect the bright yellow ball flying across. What would we do differently next time?
&lt;/p&gt;
&lt;p&gt;
&lt;ul&gt;
    &lt;li&gt;Perhaps focus on the CV algorithm as its own thing, take images in various light conditions and perfect this separately&lt;/li&gt;
    &lt;li&gt;Try to tune the RPi camera more manually. The read colour versus the write colour was obviously different. We did turn off AWB and set a manual shutter speed, but we could have done a better job of selecting the manual WB.&lt;/li&gt;
    &lt;li&gt;Get a fan for the RPi OR get a more production-ready, less hobby friendly motherboard.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;
I take extreme pride in returning to old problems after learning new techniques. That means this is not over. Until next time...
&lt;/p&gt;
&lt;p&gt;Thanks to &lt;em&gt;Meet Udeshi&lt;/em&gt; for working with me on this project. Our github repository can be found &lt;a href=&quot;https://github.com/cheekujodhpur/beetlegoose&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

</description>
            <pubDate>Fri, 01 Nov 2019 16:13:24 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/beetlegoose.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/beetlegoose.html</guid>
        </item>
        
        <item>
            <title>Undergrad Memoir</title>
            <description>&lt;p&gt;&lt;i&gt;The following article was written for and published in Physics Depart Newsletter at IIT Bombay. Requested and edited by Toshi Parmar. Co-authored by Sandesh Kalantre&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;i&gt;
(Ayush is a financial analyst at Goldman Sachs, Bengaluru. Sandesh is a graduate research assistant in condensed matter physics at the University of Maryland, College Park. They both received their undergraduate degree in Engineering Physics (class of 2018) at IIT Bombay. This article is a  personal memoir of their beloved department, their life as EP students and everything around it.)
&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;
Engineer? Physicist? Err… Engineering Physicist? In hindsight, it would be an understatement to say that the past four years have been more about discovering ourselves than anything else. Given the humdrum reality of scientifically inclined teenagers in India, it was no wonder, we both ended up being at an engineering institution, for us, that being our beloved ‘insti’, IIT Bombay. Nevertheless, it was the Engineering Physics program that got us the best of both worlds, the security of much sought after a degree from an IIT and a way to satiate our curiosity in physics and mathematics.
&lt;/p&gt;

&lt;p&gt;
We were both attracted to this strangely sounding programme at IIT Bombay because of our love for physics and mathematics from high school. For Ayush, it was “partly because Prof. Varun Bhalerao said it’d be a good idea, partly because there was some family pressure to join an IIT rather than IISc which was my next best option, and partly because Sandesh too chose IITB”. It’s probably incorrect to listen to others or do as your friends are doing, but if you’ve chosen the people and the friends well, it’s not as bad as many make it sound. 
&lt;/p&gt;

&lt;p&gt;
Education in physics is a strange thing to define. It’s challenging to draw borders in what constitutes physics and what does not. The study of stars, galaxies and black holes does belong to the realm of physics, but so does getting an operational amplifier to work in a lab. Statistical physics of gases is used to analyze the workings of earthly things like metals or superconductors to astronomical objects like white dwarfs. But more crucially so, the same ideas show up in the study of financial markets. The brilliant platter of physics courses at IITB got to us the nitty gritty details of all the above ideas. But more so, it was the wisdom about the interconnections of science and an appreciation of all things, physics or not, that we learned during our stay here stays with us today.
&lt;/p&gt;

&lt;p&gt;
Receiving education as an undergraduate is never a solitary activity. IITB is no exception. The general idea was that IITB would offer a better and varied peer which is important for undergraduate education. We were not just joining to learn Physics. We were joining to learn how to live a life. And the variety along with the intensity of experiences matters a lot for the latter. Did we know all of this going in, or did it come with four years of retrospect? Or something in between like for Ayush - “I don’t know, I have a bad memory but if I were to guess I’d say yes I did know this going in”.
&lt;/p&gt;

&lt;p&gt;
Coming from Pune and Jodhpur to Mumbai meant we were going to away from a homely environment. Though we were no longer at home, a new home itself came to us as we progressed through the years, the department. We recall a department introduction session for freshmen, which involved professors giving short descriptions of their work. We started with the senior most professors first, and as we progressed through the introductions, a happy coincidence occurred. The younger professors were, in fact, students of the older ones. After three or so such generations, came the youngest freshmen in the room, the actual students. The department constituted of a significant fraction of such alumni professors, which made being associated with the place quite rewarding. They had a sense of gratitude towards it and an anchor to their past when they were students. That’s what made them so relatable to us and vice versa. A multitude of interactions with them made us into members of a very ‘homely’ tradition, which we hope to keep up where we go. 
&lt;/p&gt;

&lt;p&gt;
Categorizing the physics department as a home is incomplete without talking about the computer lab and the department library. These two places have been fortuitously available for use to all department students during recent years. Open 24x7, they often vacillated between the hustle and bustle of a noisy cafe to a place of necessary solitude for academic work. Well, what makes a college a good college is its collegiality. We spent many weekend mornings there, over coffee and an assorted set of crazy ideas about physics or everything else. Ayush spent many sleepless nights doing hackathons, completing reports and so on. The library also doubled up as a visitor office which meant we could meet other students and professors. These rooms brought people and ideas together and they continue to do so today.
&lt;/p&gt;

&lt;p&gt;
At the end of our stay here, we diverged onto two different paths - as a financial analyst and as a graduate student in physics. For Ayush, he “never understood why people call my job as the ‘non-core’ sector. Broadly speaking, EP has partly applied math and experimental physics. Sure, I don’t use the latter in my job, but I use or see the use for most of the other skills that I learnt in the former. The interesting part of studying nature was the intellectual process. In physics, the fight is against the rules of nature, while in finance it is against the rules of humans. It is this challenge that excites me to work, every day.” As for Sandesh, “it was the same love for physics that brought me at IITB takes me to the lab almost every day as a graduate student. In our respective jobs, we still do the same thing we were taught so well at IITB, we make models and solve problems - either on exotic superconductors or the financial market is a matter of taste and details.” 
&lt;/p&gt;

&lt;p&gt;
As we look forward to our jobs for tomorrow - either measure a sample at ultra-low temperatures or use the Black-Scholes pricing model, all of it would be impossible without our education as an Engineer and as a Physicist and as much more during our stay here. Hindsight is always 20/20, and getting an EP degree was the best thing to do.  If we could rewind 4 years and could choose a different route, would we? Absolutely for one, and even perhaps do it once more so. Thank You!
&lt;/p&gt;
</description>
            <pubDate>Fri, 12 Jul 2019 16:38:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/undergrad-memoir.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/undergrad-memoir.html</guid>
        </item>
        
        <item>
            <title>The Essence of Monte Carlo</title>
            <description>&lt;p&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Eric_Veach&quot;&gt;Eric Veach&lt;/a&gt; wrote his thesis on &lt;a href=&quot;https://graphics.stanford.edu/papers/veach_thesis/thesis-bw.pdf&quot;&gt;“Robust Monte Carlo Methods for Light Transport Simulation”&lt;/a&gt;. This is a famous piece of work, considered a groundbreaking work in rendering and ubiquitous among graphics researchers and professionals. On page 12, there is a sentence which reads
&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The principle of Monte Carlo methods is not that the samples are truly random, but that random samples could be used in their place.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
It took me some time to understand what he means, and I am still not sure if I have interpret it well, but pay attention to the following piece of code, using two slightly different functions to compute the value of $\pi$ and see if you see my point.
&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-py&quot;&gt;import numpy as np                                                              
                                                                                
def mc1(N):                                                                     
    c = 0                                                                       
    N = int(N)                                                                  
    for i in range(N):                                                          
        x = np.random.random()                                                  
        y = np.random.random()                                                  
        if (x-0.5)**2 + (y-0.5)**2 &amp;lt; 0.25:                                      
            c = c+1                                                             
                                                                                
    return 4.0*float(c)/N                                                       
                                                                                
                                                                                
def mc2(N):                                                                     
    c = 0                                                                       
    _N = int(np.sqrt(N))                                                        
    for i in range(_N):                                                         
        for j in range(_N):                                                     
            x = float(i)/_N                                                     
            y = float(j)/_N                                                     
            if (x-0.5)**2 + (y-0.5)**2 &amp;lt; 0.25:                                  
                c = c+1                                                         
                                                                                
    return 4.0*float(c)/(_N*_N)                                                 
                                                                                
print mc1(1e1), mc2(1e1)                                                        
print mc1(1e2), mc2(1e2)                                                        
print mc1(1e3), mc2(1e3)                                                        
print mc1(1e4), mc2(1e4)                                                        
print mc1(1e5), mc2(1e5)                                                        
print mc1(1e6), mc2(1e6)                                                        
print mc1(1e7), mc2(1e7)  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
which generates the output
&lt;/p&gt;
&lt;pre&gt;3.2 1.77777777778
3.16 2.76
3.148 3.08012486993
3.132 3.13
3.1404 3.14088287133
3.14302 3.1413
3.1420544 3.14153285317
&lt;/pre&gt;
&lt;p&gt;The true value of $\pi$ upto 5 decimal places is $3.14159$.&lt;/p&gt;
&lt;p&gt;My two cents!&lt;/p&gt;
</description>
            <pubDate>Mon, 11 Jun 2018 04:21:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/on-monte-carlo.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/on-monte-carlo.html</guid>
        </item>
        
        <item>
            <title>Spam Slam</title>
            <description>&lt;p&gt;
Oops! This blog is posted as a guest article on another site. Please &lt;a href=&quot;https://hackinout.co/blog/blockchain-track-winner-spamslam/&quot;&gt;click here&lt;/a&gt; to redirect yourself.
&lt;/p&gt;
</description>
            <pubDate>Thu, 07 Jun 2018 08:42:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/spamslam.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/spamslam.html</guid>
        </item>
        
        <item>
            <title>Copy Constructor Magic</title>
            <description>&lt;script src=&quot;https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;&lt;i&gt;This post is co-authored with &lt;a href=&quot;http://udiboy1209.github.io/&quot;&gt;Meet Udeshi&lt;/a&gt;.&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Examine this piece of code. It has two classes &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt; has an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; and a function which fetches a new instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;, but the local variable in the function uses the same name as the member instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;bar&lt;/code&gt;. This is allowed, &lt;code class=&quot;highlighter-rouge&quot;&gt;-Wshadow&lt;/code&gt; will provide you a warning. But it is understood that this can result in unexpected or garbage output.&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
                                                                                
class foo{                                                                      
    int x,y,z;                                                                  
                                                                                
    public:                                                                     
    int gx(){return x;};                                                        
    int gy(){return y;};                                                        
    int gz(){return z;};                                                        
    foo(int _x,int _y,int _z):x(_x),y(_y),z(_z){};                              
                                                                                
    /*foo(const foo &amp;amp;kk){                                                       
        x = kk.x;                                                               
        y = kk.y;                                                               
        z = kk.z;                                                               
    }*/                                                                         
                                                                                
    void print(void){                                                           
        cout &amp;lt;&amp;lt; &quot;x: &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; &quot;y: &quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; &quot;z: &quot; &amp;lt;&amp;lt; z &amp;lt;&amp;lt; endl; 
                                                                                
    }                                                                           
};                                                                              
                                                                                
class bar{                                                                      
    foo doo;                                                                    
                                                                                
    public:                                                                     
    bar(foo _doo):doo(_doo){};                                                  
    foo scoo(void);                                                             
};                                                                              
                                                                                
                                                                                
foo bar::scoo(void){                                                            
    foo doo(doo.gx(), doo.gy(), doo.gz());                                      
    return doo;                                                                 
}                                                                               
                                                                                
int main(){                                                                     
    bar obj(foo(1,1,1));                                                        
                                                                                
    for(int i = 0;i&amp;lt;5;i++){                                                     
        obj.scoo().print();                                                     
    }                                                                           
    return 0;                                                                   
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code, for example gives the following output. &lt;i&gt;g++ -O0 -std=c++11&lt;/i&gt; with &lt;i&gt;g++ 5.4&lt;/i&gt;&lt;/p&gt;
&lt;pre&gt;x: 6299752, y: 0, z: -19107175
x: -19107175, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
&lt;/pre&gt;

&lt;p&gt;Well, what were we thinking? What we have done is b&lt;strong&gt;**&lt;/strong&gt;t and we get that for the output! Just a moment though, uncomment the explicit definition of the copy constructor for class &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; and here is what you get&lt;/p&gt;
&lt;pre&gt;x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
&lt;/pre&gt;
&lt;p&gt;That is the magic that I had to show you. Now we shall investigate where it comes from. The copy constructor definition that we put in place is equivalent to the default copy constructor that gcc would provide. What is different here? To help me further with this issue, I brought in help from Meet. Most of the following is written by him, with a few minor edits by me.&lt;/p&gt;

&lt;h6&gt;Basics of X86 assembly&lt;/h6&gt;

&lt;p&gt;
The syntax is called “intel” syntax
which is basically &lt;code class=&quot;highlighter-rouge&quot;&gt;inst dest, source&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
There are various addressing modes in X86 for either source or destination.
They can either be a register (inside the processor) or a memory location (in RAM),
or a name of some register.
&lt;/p&gt;

&lt;p&gt;
Memory locations are written inside square brackets. They can be static, or dynamically computed using an expression based on registers.
&lt;/p&gt;

&lt;p&gt;
Registers are named &lt;code class=&quot;highlighter-rouge&quot;&gt;e**&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r**&lt;/code&gt;. When same last two letters of
such two registers, they refer to the whole register and 32-bit section.
Example: &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; is 64-bit register, and &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt; refers to 32-bit MSB of &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;.
So if you store a value in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; and read from &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt;, you will get higher
32 bits of the number stored. This was done as an addition for 64-bit processors over 32-bit processors (and also backward compatibility reasons).
&lt;/p&gt;

&lt;p&gt;
Basic instructions are &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; which &lt;em&gt;copies&lt;/em&gt; value from source to destination,
&lt;code class=&quot;highlighter-rouge&quot;&gt;lea&lt;/code&gt; or load effective address which copies memory address of the source
memory location to destination (much like creating a pointer),
&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; which is responsible for calling functions.
&lt;/p&gt;

&lt;p&gt;
Special purpose registers are &lt;code class=&quot;highlighter-rouge&quot;&gt;rsp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;rbp&lt;/code&gt; which are stack pointer
and stack-base pointer or frame pointer. They store the location of the stack for
the function.
&lt;/p&gt;

&lt;h6&gt;What goes wrong when shadowing&lt;/h6&gt;

&lt;p&gt;
This is the assembly implementation of function bar::scoo()
&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;push   rbp
mov    rbp,rsp
push   r12
push   rbx
sub    rsp,0x40
mov    QWORD PTR [rbp-0x38],rdi
mov    rax,QWORD PTR fs:0x28

mov    QWORD PTR [rbp-0x18],rax
xor    eax,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b28 &amp;lt;_ZN3foo2gzEv&amp;gt;
mov    r12d,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b16 &amp;lt;_ZN3foo2gyEv&amp;gt;
mov    ebx,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b06 &amp;lt;_ZN3foo2gxEv&amp;gt;
mov    esi,eax
lea    rax,[rbp-0x30]
mov    ecx,r12d
mov    edx,ebx
mov    rdi,rax
call   b3a &amp;lt;_ZN3fooC1Eiii&amp;gt;
mov    rax,QWORD PTR [rbp-0x30]
mov    QWORD PTR [rbp-0x24],rax
mov    eax,DWORD PTR [rbp-0x28]
mov    DWORD PTR [rbp-0x1c],eax
mov    rdx,QWORD PTR [rbp-0x24]
mov    eax,DWORD PTR [rbp-0x1c]
mov    rcx,rdx
mov    edx,eax
mov    rax,rcx
mov    rbx,QWORD PTR [rbp-0x18]
xor    rbx,QWORD PTR fs:0x28

je     a05 &amp;lt;_ZN3bar4scooEv+0x8b&amp;gt;
call   840 &amp;lt;__stack_chk_fail@plt&amp;gt;
add    rsp,0x40
pop    rbx
pop    r12
pop    rbp
ret    
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt; `sub rsp,0x40` subtracts 0x40 or 64 from register `rsp`
  i.e. allocating 64 bytes of space on the stack (stacks grow downward nowadays,
  so push operatins will decrement stack pointer)&lt;/li&gt;
 
&lt;li&gt; When calling any function of class foo, we have to provide a pointer to instance of foo.
  Much similar to how you pass a special variable `self` in python for member function calls.
  So in this, the foo instance has been stored at `[rbp-0x30]`. 
  You can see that there are `lea rax, [rbp-0x30]` instructions before every function call.&lt;/li&gt;

&lt;li&gt; `call &amp;lt;_ZN3foo2gzEv&amp;gt;` calls foo::gz() using instance of foo at `[rbp-0x30]`.
  Notice that this instance isn't initialised at all when we call gx(), gy() or gz().
  Hence, whatever values `[rbp-0x30]` has would be garbage. The calls return garbage
  and store it in local registers&lt;/li&gt;

&lt;li&gt; The function then passes these garbage value to the final init call which is
  `call &amp;lt;_ZN3fooC1Eiii&amp;gt;`. Basically our `doo` instance is reading from its uninitialized
  self and using those values to then later finally initialize itself.&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;
&lt;em&gt;&lt;b&gt;Note&lt;/b&gt;: In this case, the new &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; variable was first allocated on the stack of function &lt;code class=&quot;highlighter-rouge&quot;&gt;scoo&lt;/code&gt;
and hence held garbage. This happens because the lack of copy constructor
makes C++ restort to using internal copy operations 
i.e. when returning the final object, the total 12 bytes of object foo
are read into one 32-bit register and one 64-bit regster (rdx and eax) and returned&lt;/em&gt; 
&lt;/p&gt;

&lt;h6&gt;How does the copy constructor affect this?&lt;/h6&gt;

&lt;p&gt;
The copy constructor leads to a change in the calling convention of the function scoo.
Previously, it returned the value by storing it inside registers. Now the caller(main function) provides callee(scoo function) with a pointer where it should store return value. You could think of it as pass by reference but for the return value.
&lt;/p&gt;

&lt;p&gt;
Assembly for function bar::scoo()
&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;
push   rbp
mov    rbp,rsp
push   r12
push   rbx
sub    rsp,0x20
mov    QWORD PTR [rbp-0x28],rdi
mov    QWORD PTR [rbp-0x30],rsi
mov    rax,QWORD PTR fs:0x28

mov    QWORD PTR [rbp-0x18],rax
xor    eax,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   b0c &amp;lt;_ZN3foo2gzEv&amp;gt;
mov    r12d,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   afa &amp;lt;_ZN3foo2gyEv&amp;gt;
mov    ebx,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   aea &amp;lt;_ZN3foo2gxEv&amp;gt;
mov    esi,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    ecx,r12d
mov    edx,ebx
mov    rdi,rax
call   b1e &amp;lt;_ZN3fooC1Eiii&amp;gt;
nop
mov    rax,QWORD PTR [rbp-0x28]
mov    rdx,QWORD PTR [rbp-0x18]
xor    rdx,QWORD PTR fs:0x28

je     9f1 &amp;lt;_ZN3bar4scooEv+0x77&amp;gt;
call   840 &amp;lt;__stack_chk_fail@plt&amp;gt;
add    rsp,0x20
pop    rbx
pop    r12
pop    rbp
ret    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Notice the difference here: instead of loading &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt; value using &lt;code class=&quot;highlighter-rouge&quot;&gt;lea&lt;/code&gt; instruction, 
&lt;code class=&quot;highlighter-rouge&quot;&gt;mov rax,QWORD PTR [rbp-0x28]&lt;/code&gt; is being used.
This will not load address &lt;code class=&quot;highlighter-rouge&quot;&gt;rbp-0x28&lt;/code&gt; into &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt;, but simply copy value at
location &lt;code class=&quot;highlighter-rouge&quot;&gt;[rbp-0x28]&lt;/code&gt; into &lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
But still, the same procedure is being conducted. 
The function calls &lt;code class=&quot;highlighter-rouge&quot;&gt;gx()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gy()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;gz()&lt;/code&gt; on this
uninitialised location given by value of &lt;code class=&quot;highlighter-rouge&quot;&gt;[rbp-0x28]&lt;/code&gt;
and then calls the constructor with those values.
&lt;/p&gt;

&lt;p&gt;
Then how does the correct value pop out?
We need to look at main() function where scoo() is called.
&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code&gt;
mov    QWORD PTR [rbp-0x8],rax
xor    eax,eax
lea    rax,[rbp-0x14]
mov    ecx,0x1
mov    edx,0x1
mov    esi,0x1
mov    rdi,rax
call   b1e &amp;lt;_ZN3fooC1Eiii&amp;gt;
lea    rdx,[rbp-0x14]
lea    rax,[rbp-0x20]
mov    rsi,rdx
mov    rdi,rax
call   c36 &amp;lt;_ZN3barC1E3foo&amp;gt;
mov    DWORD PTR [rbp-0x24],0x0
cmp    DWORD PTR [rbp-0x24],0x4
jg     a71 &amp;lt;main+0x77&amp;gt;
lea    rax,[rbp-0x14]
lea    rdx,[rbp-0x20]
mov    rsi,rdx
mov    rdi,rax
call   97a &amp;lt;_ZN3bar4scooEv&amp;gt;
lea    rax,[rbp-0x14]
mov    rdi,rax
call   b88 &amp;lt;_ZN3foo5printEv&amp;gt;
add    DWORD PTR [rbp-0x24],0x1
jmp    a46 &amp;lt;main+0x4c&amp;gt;
mov    eax,0x0
mov    rcx,QWORD PTR [rbp-0x8]
xor    rcx,QWORD PTR fs:0x28
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
We store the value of register &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;[rbp-0x28]&lt;/code&gt; in function scoo(),
hence whatever is stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; at time of calling would be used as
instance location of return foo class.
&lt;/p&gt;

&lt;p&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;lea rax,[rbp-0x14]&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;mov rdi,rax&lt;/code&gt; lead to value &lt;code class=&quot;highlighter-rouge&quot;&gt;rbp-0x14&lt;/code&gt; being passed to scoo as
location for return foo class. Note that is location is in the stack of &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;
and not &lt;code class=&quot;highlighter-rouge&quot;&gt;scoo()&lt;/code&gt; like previous case. 
&lt;/p&gt;

&lt;p&gt;
Notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;rbp-0x14&lt;/code&gt; is first passed to the foo constructor. This is because of this line
of code
&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;    bar obj(foo(1,1,1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
Here a temp &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; object has to be initialised and then passed to bar constructor.
When that constructor is called, the &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; object is not needed, hence compiler
tries to use that memory slot for the returned &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt; object. Ideally it should not have
optimised this because we have switched off optimisation with &lt;code class=&quot;highlighter-rouge&quot;&gt;-O0&lt;/code&gt;
but this may be a flaw in GCC. So, instead of picking up garbage values in &lt;code class=&quot;highlighter-rouge&quot;&gt;scoo()&lt;/code&gt;
it picks up the correct values from the temp variable because of reused stack slot.
&lt;/p&gt;

&lt;p&gt;
The proof of this comes from the fact that, when compiled with another compiler like clang,
this behaviour is not replicated. Hence it is important to know that even the second code has
the error of shadowing, it just isn’t being seen in the output due to a happy accident.
&lt;/p&gt;

&lt;p&gt;Our four cents!&lt;/p&gt;
</description>
            <pubDate>Sun, 20 May 2018 18:12:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/copy-constructor-magic.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/copy-constructor-magic.html</guid>
        </item>
        
        <item>
            <title>Witcher, Game of Thrones and Predestination: Inspirations from Irish Mythology</title>
            <description>&lt;p&gt;
I was home for the past one week, having a compulsory vacation enforced by my family. I spent it reading the Witcher series. To those of you who don’t know about them, &lt;a href=&quot;https://en.wikipedia.org/wiki/Andrzej_Sapkowski#The_Witcher_Saga&quot;&gt;The Witcher&lt;/a&gt; is a polish fantasy series by Andrzej Sapkowski. In the opinion of many, what makes them distinctive from fantasy series like LOTR and Harry Potter are the grey shades of morality portrayed in the world. In LOTR and HP, there is a good and there is an evil and at the end of the day, the good has to triumph over evil. In Witcher, every decision taken has varying consequences for different characters; good and bad. This fascinates the eye, because of its &lt;i&gt;natural&lt;/i&gt; appeal.
&lt;/p&gt;
&lt;p&gt;
Game of Thrones, the popular TV series, is the second thing that comes to my mind when you think of a grey portrayal of the world. I have not read the ASOIF books, but I am an avid follower of the show and hence believe I have an idea of the major keypoints of the show. And what I’ll be talking about here are the striking similarities on some of the plotlines of Witcher and Game of Thrones. Some of them are built out of fan theories I read about GoT as well.
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Political and sexual intrigue, although since Witcher centers around one individual and his destiny, the political aspects are perhaps not as elaborate as GoT.&lt;/li&gt;
&lt;li&gt;Witcher has an elven race &lt;i&gt;Aen Sidhe&lt;/i&gt;, and GoT's white walkers are like &lt;i&gt;sidhe&lt;/i&gt; made of ice, both derived from Ao Si in Irish mythology. We also know that Children of the Forest made White Walkers so they represent &lt;i&gt;Aen Sidhe&lt;/i&gt; better, and then they have a sister race called &lt;i&gt;Aen Elle&lt;/i&gt; which looks like a representation of the Others in Irish mythology, and of WW in GoT. Witcher's &lt;i&gt;Aen Elle&lt;/i&gt; have their own version of rogue riders called the Wild Hunt.&lt;/li&gt;
&lt;li&gt;A major problem which surrounds the world as per a prophecy is the coming of a great winter; a great iceage, the Big Winter, the Big Chill, Aep Deireadh and many other names used for a long iceage. Witcher brings in a bit of science too by discussing that this will be effectively due to a change in tilt of Earth's axis.&lt;/li&gt;
&lt;li&gt;Both of them have a central character who can travel through Space and Time. This is Witcher's Cirilla or Ciri, and GoT's Brandon Stark. Although, in the case of GoT, it is only fan theories which talk about a predestination. Witcher, on the other hand, is very explicit to center the story around Ciri's predestination.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
I spent long hours searching for popular Irish mythological stories so we could establish a connection. Witcher was published before ASOIF and ASOIF was published by the time Witcher was well known to the English speaking world. These are just my reflections.
&lt;/p&gt;
</description>
            <pubDate>Sat, 18 Jun 2016 12:56:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/witcher-got-irish-mytho.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/witcher-got-irish-mytho.html</guid>
        </item>
        
        <item>
            <title>On Slicing Python Lists</title>
            <description>&lt;p&gt;
A lot many are familiar with Python lists and the feature of slicing, although I find the description that most tutorials not intuitive enough. Here is how it goes.&lt;br /&gt;
Let us start with defining an array of 10 elements
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [i for i in range(10)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
Now, the following I assume you’re familiar with.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[3:6]
[3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
And the way people think about it is selecting elements starting with &lt;i&gt;index 3&lt;/i&gt; till and including the element with &lt;i&gt;index 6-1=5.&lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;
Do you digest that? I cannot. Why do I include the first index while not the second one? If I think in terms of indices, I have to spend my brain power in subtracting the second index by one, and I tell you I am very lazy about that. 
&lt;br /&gt;
Then there are people who say that you start with &lt;i&gt;index 3&lt;/i&gt; and choose &lt;i&gt;6-3=3&lt;/i&gt; elements there on. This does work because we see the following happening.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[4:4]
[]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
But I do not understand that if I were inventing slicing, and I would want people to think in terms of an index and a length, why would I not just keep length as the second parameter? In this &lt;b&gt;hypothetical&lt;/b&gt; situation,
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[3:3]
[3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;i&gt;DISCLAIMER: I do not claimer that this is how it went but I’ll now talk about how I like to look at slicing&lt;/i&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[3:]
[3, 4, 5, 6, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
I like to say that doing this &lt;i&gt;skips&lt;/i&gt; the first &lt;i&gt;three&lt;/i&gt; elements and gives the rest.
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[:6]
[0, 1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
And this picks the first &lt;i&gt;six&lt;/i&gt; elements. Simple really!
&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;gt;&amp;gt;&amp;gt; a[3:6]
[3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
This just gives the &lt;i&gt;intersection&lt;/i&gt; of the two.
&lt;/p&gt;
&lt;p&gt;
My two cents.
&lt;/p&gt;
</description>
            <pubDate>Fri, 03 Jun 2016 02:21:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/splicing.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/splicing.html</guid>
        </item>
        
        <item>
            <title>Circle enclosing N lattice points</title>
            <description>&lt;p&gt;Did you know?&lt;br /&gt;For every natural number N, there exists a circle enclosing exactly N lattice points!&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;image left&quot;&gt;&lt;img src=&quot;https://media.giphy.com/media/26vUCSK9K5wTm5fwI/giphy.gif&quot; alt=&quot;gif demonstrating fact&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The above was posted on the Facebook group of Math n Physics Club of my institute. It triggered a discussion about the center of such a circle with one guy commenting without reason enough that it has to be an irrational point and any irrational point would do.
&lt;/p&gt;
&lt;p&gt;I found it interesting and thought over it while taking a shower. &lt;i&gt;If&lt;/i&gt; the center is at origin, then this is impossible. If you try to enclose a point at a distance $\sqrt{d^2}$, you will find that $d^2 = x^2 + y^2$ where you don’t have a unique choice of $x$ and $y$.&lt;/p&gt;
&lt;p&gt;Now note that if the center is a rational point, say $(\frac{a}{b},\frac{c}{d})$, then you can scale the space by $bd$, then the center lies at $(ad,bc)$ and then a simple translation will take you to origin and our hypothesis is reduced to the above case raising a contradiction against our assumption that the center is a rational point.&lt;/p&gt;
&lt;p&gt;Thus, the center must be an irrational point. I do not know if any irrational point would do though.&lt;/p&gt;
&lt;p&gt;My two cents!&lt;/p&gt;
</description>
            <pubDate>Sat, 14 May 2016 20:01:00 +0530</pubDate>
            <link>http://cheekujodhpur.github.io/bposts/n-points-in-circle.html</link>
            <guid isPermaLink="true">http://cheekujodhpur.github.io/bposts/n-points-in-circle.html</guid>
        </item>
        
    </channel>
</rss>
