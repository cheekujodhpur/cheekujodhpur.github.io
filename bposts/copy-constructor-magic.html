<!DOCTYPE html>
<!--
  Original Design: Spectral by HTML5 UP
    html5up.net | @n33co
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
  Jekyll build mod
  Modified By: Kumar Ayush
-->
<html>

  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Copy Constructor Magic - Kumar Ayush</title>
  <meta name="description" content="This post is co-authored with Meet Udeshi.">
  <!-- og tags -->
  <meta property="og:title" content="Copy Constructor Magic - Kumar Ayush" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="http://cheekujodhpur.github.io/bposts/copy-constructor-magic.html" />
  <meta property="og:image" content="/images/me_reading.jpg" />

  <!--[if lte IE 8]><script src="/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="canonical" href="http://cheekujodhpur.github.io/bposts/copy-constructor-magic.html">
  <link rel="stylesheet" href="/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/css/ie9.css" /><![endif]-->
  <link rel="alternate" type="application/rss+xml" title="Kumar Ayush" href="http://cheekujodhpur.github.io/feed.xml">
   <script type="text/x-mathjax-config">                                       
      MathJax.Hub.Config({                                                          
                tex2jax: {                                                      
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],                                 
      processEscapes: true                                                      
    }                                                                           
  });                                                                           
   </script>                                                                   
   <script type="text/javascript"                                              
           src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
   </script>
</head>


  <body>

    <!-- Page Wrapper -->
    <div id="page-wrapper">

      <!-- Header -->
<header id="header">
  <h1><a href="/index.html">Kumar Ayush</a></h1>
  <nav id="nav">
    <ul>
      <li class="special">
        <a href="#menu" class="menuToggle"><span>Menu</span></a>
        <div id="menu">
          <ul>
            <li><a href="/index.html">Home</a></li>
            
            
            <li><a href="/blog/">Blog</a></li>
            
            
            
            
            
            
            
            
            
            
            
            
            
            <li><a href="/projects/">Projects</a></li>
            
            
            <li><a href="/feed.xml"
                   class="icon fa-feed"> RSS Feed</a></li>
          </ul>
        </div>
      </li>
    </ul>
  </nav>
</header>


      <article id="main">

  <section class="wrapper style5">
    <div class="inner">
        
        <h2>Copy Constructor Magic</h2>
        <h3></h3>
        <p><em>20 May 2018</em></p>

        <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

<p><i>This post is co-authored with <a href="http://udiboy1209.github.io/">Meet Udeshi</a>.</i></p>

<p>Examine this piece of code. It has two classes <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">bar</code>, <code class="highlighter-rouge">bar</code> has an instance of <code class="highlighter-rouge">foo</code> and a function which fetches a new instance of <code class="highlighter-rouge">foo</code>, but the local variable in the function uses the same name as the member instance of <code class="highlighter-rouge">foo</code> in <code class="highlighter-rouge">bar</code>. This is allowed, <code class="highlighter-rouge">-Wshadow</code> will provide you a warning. But it is understood that this can result in unexpected or garbage output.</p>
<pre class="prettyprint"><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
                                                                                
class foo{                                                                      
    int x,y,z;                                                                  
                                                                                
    public:                                                                     
    int gx(){return x;};                                                        
    int gy(){return y;};                                                        
    int gz(){return z;};                                                        
    foo(int _x,int _y,int _z):x(_x),y(_y),z(_z){};                              
                                                                                
    /*foo(const foo &amp;kk){                                                       
        x = kk.x;                                                               
        y = kk.y;                                                               
        z = kk.z;                                                               
    }*/                                                                         
                                                                                
    void print(void){                                                           
        cout &lt;&lt; "x: " &lt;&lt; x &lt;&lt; ", " &lt;&lt; "y: " &lt;&lt; y &lt;&lt; ", " &lt;&lt; "z: " &lt;&lt; z &lt;&lt; endl; 
                                                                                
    }                                                                           
};                                                                              
                                                                                
class bar{                                                                      
    foo doo;                                                                    
                                                                                
    public:                                                                     
    bar(foo _doo):doo(_doo){};                                                  
    foo scoo(void);                                                             
};                                                                              
                                                                                
                                                                                
foo bar::scoo(void){                                                            
    foo doo(doo.gx(), doo.gy(), doo.gz());                                      
    return doo;                                                                 
}                                                                               
                                                                                
int main(){                                                                     
    bar obj(foo(1,1,1));                                                        
                                                                                
    for(int i = 0;i&lt;5;i++){                                                     
        obj.scoo().print();                                                     
    }                                                                           
    return 0;                                                                   
}</code></pre>

<p>The above code, for example gives the following output. <i>g++ -O0 -std=c++11</i> with <i>g++ 5.4</i></p>
<pre>x: 6299752, y: 0, z: -19107175
x: -19107175, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
x: 4197253, y: 0, z: 4197253
</pre>

<p>Well, what were we thinking? What we have done is b<strong>**</strong>t and we get that for the output! Just a moment though, uncomment the explicit definition of the copy constructor for class <code class="highlighter-rouge">foo</code> and here is what you get</p>
<pre>x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
x: 1, y: 1, z: 1
</pre>
<p>That is the magic that I had to show you. Now we shall investigate where it comes from. The copy constructor definition that we put in place is equivalent to the default copy constructor that gcc would provide. What is different here? To help me further with this issue, I brought in help from Meet. Most of the following is written by him, with a few minor edits by me.</p>

<h6>Basics of X86 assembly</h6>

<p>
The syntax is called “intel” syntax
which is basically <code class="highlighter-rouge">inst dest, source</code>.
</p>

<p>
There are various addressing modes in X86 for either source or destination.
They can either be a register (inside the processor) or a memory location (in RAM),
or a name of some register.
</p>

<p>
Memory locations are written inside square brackets. They can be static, or dynamically computed using an expression based on registers.
</p>

<p>
Registers are named <code class="highlighter-rouge">e**</code> and <code class="highlighter-rouge">r**</code>. When same last two letters of
such two registers, they refer to the whole register and 32-bit section.
Example: <code class="highlighter-rouge">eax</code> is 64-bit register, and <code class="highlighter-rouge">rax</code> refers to 32-bit MSB of <code class="highlighter-rouge">eax</code>.
So if you store a value in <code class="highlighter-rouge">eax</code> and read from <code class="highlighter-rouge">rax</code>, you will get higher
32 bits of the number stored. This was done as an addition for 64-bit processors over 32-bit processors (and also backward compatibility reasons).
</p>

<p>
Basic instructions are <code class="highlighter-rouge">mov</code> which <em>copies</em> value from source to destination,
<code class="highlighter-rouge">lea</code> or load effective address which copies memory address of the source
memory location to destination (much like creating a pointer),
<code class="highlighter-rouge">call</code> which is responsible for calling functions.
</p>

<p>
Special purpose registers are <code class="highlighter-rouge">rsp</code> and <code class="highlighter-rouge">rbp</code> which are stack pointer
and stack-base pointer or frame pointer. They store the location of the stack for
the function.
</p>

<h6>What goes wrong when shadowing</h6>

<p>
This is the assembly implementation of function bar::scoo()
</p>

<pre class="prettyprint"><code>push   rbp
mov    rbp,rsp
push   r12
push   rbx
sub    rsp,0x40
mov    QWORD PTR [rbp-0x38],rdi
mov    rax,QWORD PTR fs:0x28

mov    QWORD PTR [rbp-0x18],rax
xor    eax,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b28 &lt;_ZN3foo2gzEv&gt;
mov    r12d,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b16 &lt;_ZN3foo2gyEv&gt;
mov    ebx,eax
lea    rax,[rbp-0x30]
mov    rdi,rax
call   b06 &lt;_ZN3foo2gxEv&gt;
mov    esi,eax
lea    rax,[rbp-0x30]
mov    ecx,r12d
mov    edx,ebx
mov    rdi,rax
call   b3a &lt;_ZN3fooC1Eiii&gt;
mov    rax,QWORD PTR [rbp-0x30]
mov    QWORD PTR [rbp-0x24],rax
mov    eax,DWORD PTR [rbp-0x28]
mov    DWORD PTR [rbp-0x1c],eax
mov    rdx,QWORD PTR [rbp-0x24]
mov    eax,DWORD PTR [rbp-0x1c]
mov    rcx,rdx
mov    edx,eax
mov    rax,rcx
mov    rbx,QWORD PTR [rbp-0x18]
xor    rbx,QWORD PTR fs:0x28

je     a05 &lt;_ZN3bar4scooEv+0x8b&gt;
call   840 &lt;__stack_chk_fail@plt&gt;
add    rsp,0x40
pop    rbx
pop    r12
pop    rbp
ret    
</code></pre>

<ul>
<li> `sub rsp,0x40` subtracts 0x40 or 64 from register `rsp`
  i.e. allocating 64 bytes of space on the stack (stacks grow downward nowadays,
  so push operatins will decrement stack pointer)</li>
 
<li> When calling any function of class foo, we have to provide a pointer to instance of foo.
  Much similar to how you pass a special variable `self` in python for member function calls.
  So in this, the foo instance has been stored at `[rbp-0x30]`. 
  You can see that there are `lea rax, [rbp-0x30]` instructions before every function call.</li>

<li> `call &lt;_ZN3foo2gzEv&gt;` calls foo::gz() using instance of foo at `[rbp-0x30]`.
  Notice that this instance isn't initialised at all when we call gx(), gy() or gz().
  Hence, whatever values `[rbp-0x30]` has would be garbage. The calls return garbage
  and store it in local registers</li>

<li> The function then passes these garbage value to the final init call which is
  `call &lt;_ZN3fooC1Eiii&gt;`. Basically our `doo` instance is reading from its uninitialized
  self and using those values to then later finally initialize itself.</li>

</ul>

<p>
<em><b>Note</b>: In this case, the new <code class="highlighter-rouge">foo</code> variable was first allocated on the stack of function <code class="highlighter-rouge">scoo</code>
and hence held garbage. This happens because the lack of copy constructor
makes C++ restort to using internal copy operations 
i.e. when returning the final object, the total 12 bytes of object foo
are read into one 32-bit register and one 64-bit regster (rdx and eax) and returned</em> 
</p>

<h6>How does the copy constructor affect this?</h6>

<p>
The copy constructor leads to a change in the calling convention of the function scoo.
Previously, it returned the value by storing it inside registers. Now the caller(main function) provides callee(scoo function) with a pointer where it should store return value. You could think of it as pass by reference but for the return value.
</p>

<p>
Assembly for function bar::scoo()
</p>

<pre class="prettyprint"><code>
push   rbp
mov    rbp,rsp
push   r12
push   rbx
sub    rsp,0x20
mov    QWORD PTR [rbp-0x28],rdi
mov    QWORD PTR [rbp-0x30],rsi
mov    rax,QWORD PTR fs:0x28

mov    QWORD PTR [rbp-0x18],rax
xor    eax,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   b0c &lt;_ZN3foo2gzEv&gt;
mov    r12d,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   afa &lt;_ZN3foo2gyEv&gt;
mov    ebx,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    rdi,rax
call   aea &lt;_ZN3foo2gxEv&gt;
mov    esi,eax
mov    rax,QWORD PTR [rbp-0x28]
mov    ecx,r12d
mov    edx,ebx
mov    rdi,rax
call   b1e &lt;_ZN3fooC1Eiii&gt;
nop
mov    rax,QWORD PTR [rbp-0x28]
mov    rdx,QWORD PTR [rbp-0x18]
xor    rdx,QWORD PTR fs:0x28

je     9f1 &lt;_ZN3bar4scooEv+0x77&gt;
call   840 &lt;__stack_chk_fail@plt&gt;
add    rsp,0x20
pop    rbx
pop    r12
pop    rbp
ret    
</code></pre>

<p>
Notice the difference here: instead of loading <code class="highlighter-rouge">rax</code> value using <code class="highlighter-rouge">lea</code> instruction, 
<code class="highlighter-rouge">mov rax,QWORD PTR [rbp-0x28]</code> is being used.
This will not load address <code class="highlighter-rouge">rbp-0x28</code> into <code class="highlighter-rouge">rax</code>, but simply copy value at
location <code class="highlighter-rouge">[rbp-0x28]</code> into <code class="highlighter-rouge">rax</code>.
</p>

<p>
But still, the same procedure is being conducted. 
The function calls <code class="highlighter-rouge">gx()</code>, <code class="highlighter-rouge">gy()</code>, <code class="highlighter-rouge">gz()</code> on this
uninitialised location given by value of <code class="highlighter-rouge">[rbp-0x28]</code>
and then calls the constructor with those values.
</p>

<p>
Then how does the correct value pop out?
We need to look at main() function where scoo() is called.
</p>

<pre class="prettyprint"><code>
mov    QWORD PTR [rbp-0x8],rax
xor    eax,eax
lea    rax,[rbp-0x14]
mov    ecx,0x1
mov    edx,0x1
mov    esi,0x1
mov    rdi,rax
call   b1e &lt;_ZN3fooC1Eiii&gt;
lea    rdx,[rbp-0x14]
lea    rax,[rbp-0x20]
mov    rsi,rdx
mov    rdi,rax
call   c36 &lt;_ZN3barC1E3foo&gt;
mov    DWORD PTR [rbp-0x24],0x0
cmp    DWORD PTR [rbp-0x24],0x4
jg     a71 &lt;main+0x77&gt;
lea    rax,[rbp-0x14]
lea    rdx,[rbp-0x20]
mov    rsi,rdx
mov    rdi,rax
call   97a &lt;_ZN3bar4scooEv&gt;
lea    rax,[rbp-0x14]
mov    rdi,rax
call   b88 &lt;_ZN3foo5printEv&gt;
add    DWORD PTR [rbp-0x24],0x1
jmp    a46 &lt;main+0x4c&gt;
mov    eax,0x0
mov    rcx,QWORD PTR [rbp-0x8]
xor    rcx,QWORD PTR fs:0x28
</code></pre>

<p>
We store the value of register <code class="highlighter-rouge">rdi</code> in <code class="highlighter-rouge">[rbp-0x28]</code> in function scoo(),
hence whatever is stored in <code class="highlighter-rouge">rdi</code> at time of calling would be used as
instance location of return foo class.
</p>

<p>
<code class="highlighter-rouge">lea rax,[rbp-0x14]</code> and <code class="highlighter-rouge">mov rdi,rax</code> lead to value <code class="highlighter-rouge">rbp-0x14</code> being passed to scoo as
location for return foo class. Note that is location is in the stack of <code class="highlighter-rouge">main()</code>
and not <code class="highlighter-rouge">scoo()</code> like previous case. 
</p>

<p>
Notice that <code class="highlighter-rouge">rbp-0x14</code> is first passed to the foo constructor. This is because of this line
of code
</p>

<pre class="prettyprint"><code class="language-cpp">    bar obj(foo(1,1,1));
</code></pre>

<p>
Here a temp <code class="highlighter-rouge">foo</code> object has to be initialised and then passed to bar constructor.
When that constructor is called, the <code class="highlighter-rouge">foo</code> object is not needed, hence compiler
tries to use that memory slot for the returned <code class="highlighter-rouge">foo</code> object. Ideally it should not have
optimised this because we have switched off optimisation with <code class="highlighter-rouge">-O0</code>
but this may be a flaw in GCC. So, instead of picking up garbage values in <code class="highlighter-rouge">scoo()</code>
it picks up the correct values from the temp variable because of reused stack slot.
</p>

<p>
The proof of this comes from the fact that, when compiled with another compiler like clang,
this behaviour is not replicated. Hence it is important to know that even the second code has
the error of shadowing, it just isn’t being seen in the output due to a happy accident.
</p>

<p>Our four cents!</p>

    </div>
  </section>

</article>


      <!-- Footer -->
<footer id="footer">
  <ul class="icons">
    
    
    
    <li><a target="_blank" href="https://twitter.com/kumarayush4ever" class="icon fa-twitter"
           ><span class="label">twitter</span></a></li>
    
    
    
    
    
    <li><a target="_blank" href="https://github.com/cheekujodhpur" class="icon fa-github"
           ><span class="label">github</span></a></li>
    
    
    
    
    
    <li><a target="_blank" href="https://linkedin.com/in/cheekujodhpur" class="icon fa-linkedin-square"
           ><span class="label">linkedin-square</span></a></li>
    
    
    
    
    
    <li><a target="_blank" href="https://facebook.com/cheekujodhpur" class="icon fa-facebook-official"
           ><span class="label">facebook-official</span></a></li>
    
    
    
    
    
    <li><a target="_blank" href="https://plus.google.com/u/0/+cheekujodhpur" class="icon fa-google-plus-square"
           ><span class="label">google-plus-square</span></a></li>
    
    
    
  </ul>
  <ul class="copyright">
    <li>&copy; 
    
    2019
    Kumar Ayush</li>
    <li>Design: <a href="http://html5up.net" target="_blank">HTML5 UP</a></li>
    <li>Built with: <a href="http://jekyllrb.com" target="_blank">Jekyll</a></li>
  </ul>
</footer>


      <!-- Scripts -->
<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollex.min.js"></script>
<script src="/js/jquery.scrolly.min.js"></script>
<script src="/js/skel.min.js"></script>
<script src="/js/util.js"></script>
<!--[if lte IE 8]><script src="/js/ie/respond.min.js"></script><![endif]-->
<script>
function handleLinks () {
    // Don't open our own site's links in new tabs
    var host = location.hostname 
        // Grab and loop over all <a> elements
        var allLinks = document.querySelectorAll('a') 
        for (var i = 0; i < allLinks.length; ++i) {
            // if links are external and not empty
            if (allLinks[i].hostname !== host && allLinks[i].hostname !== '') {
                allLinks[i].target = '_blank'
            }
        }
}
</script>
<script src="/js/main.js"></script>


    </div>

  </body>

</html>
